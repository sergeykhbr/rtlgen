// 
//  Copyright 2025 Sergey Khabarov, sergeykhbr@gmail.com
// 
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
// 
//      http://www.apache.org/licenses/LICENSE-2.0
// 
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.
// 

#include "pcie_dma.h"

pcie_dma::pcie_dma(GenObject *parent, const char *name, const char *comment) :
    ModuleObject(parent, "pcie_dma", name, comment),
    i_nrst(this, "i_nrst", "1", "System Reset: active LOW"),
    i_clk(this, "i_clk", "1", "System bus clock"),
    i_pcie_usr_rst(this, "i_pcie_usr_rst", "1", "PCIE user rest: active HIGH"),
    i_pcie_usr_clk(this, "i_pcie_usr_clk", "1", "PCIE clock generated by end-point"),
    _text0_(this, "PCIE EP - DMA engine interface"),
    i_pcie_completer_id(this, "i_pcie_completer_id", "16", "Bus, Device, Function"),
    i_pcie_dmai(this, "i_pcie_dmai", "PCIE-EP to system DMA requests"),
    o_pcie_dmao(this, "o_pcie_dmao", "System DMA responds to PCIE EP"),
    _text1_(this, "DMA engine interface - System on Chip interface"),
    o_xmst_cfg(this, "o_xmst_cfg", "PCIE DMA master interface descriptor"),
    i_xmsti(this, "i_xmsti"),
    o_xmsto(this, "o_xmsto"),
    // params
    _fmt0_(this, ""),
    _fmt1_(this, "fmt: indicates the size of the header"),
    TLP_FMT_3DW_NOPAYLOAD(this, "TLP_FMT_3DW_NOPAYLOAD", "2", "0", "3DW header without payload"),
    TLP_FMT_4DW_NOPAYLOAD(this, "TLP_FMT_4DW_NOPAYLOAD", "2", "1", "4DW header without payload"),
    TLP_FMT_3DW_PAYLOAD(this, "TLP_FMT_3DW_PAYLOAD", "2", "2", "3DW header with payload"),
    TLP_FMT_4DW_PAYLOAD(this, "TLP_FMT_4DW_PAYLOAD", "2", "3", "4DW header with payload"),
    _tlp0_(this, ""),
    _tlp1_(this, "TLP[30:29] = fmt; TLP[28:24] = type"),
    TLP_FMT_TYPE_RD_MEM32(this, "TLP_FMT_TYPE_RD_MEM32", "7", "0x00", NO_COMMENT),
    TLP_FMT_TYPE_WR_MEM32(this, "TLP_FMT_TYPE_WR_MEM32", "7", "0x20", NO_COMMENT),
    TLP_FMT_TYPE_RD_MEM64(this, "TLP_FMT_TYPE_RD_MEM64", "7", "0x10", NO_COMMENT),
    TLP_FMT_TYPE_WR_MEM64(this, "TLP_FMT_TYPE_WR_MEM64", "7", "0x30", NO_COMMENT),
    TLP_FMT_TYPE_RD_IO32(this, "TLP_FMT_TYPE_RD_IO32", "7", "0x02", NO_COMMENT),
    TLP_FMT_TYPE_WR_IO32(this, "TLP_FMT_TYPE_WR_IO32", "7", "0x22", NO_COMMENT),
    _state0_(this, ""),
    _state1_(this, "State machine to parse TLP"),
    STATE_RST(this, "STATE_RST", "8", "0x0", NO_COMMENT),
    STATE_DW3DW4(this, "STATE_DW3DW4", "8", "1", NO_COMMENT),
    STATE_AR(this, "STATE_AR", "8", "2", NO_COMMENT),
    STATE_R(this, "STATE_R", "8", "3", NO_COMMENT),
    STATE_AW(this, "STATE_AW", "8", "4", NO_COMMENT),
    STATE_W(this, "STATE_W", "8", "5", NO_COMMENT),
    STATE_B(this, "STATE_B", "8", "6", NO_COMMENT),
    STATE_RESP_DW0DW1(this, "STATE_RESP_DW0DW1", "8", "7", NO_COMMENT),
    STATE_RESP_DW2DW3(this, "STATE_RESP_DW2DW3", "8", "8", NO_COMMENT),
    STATE_RESP_PAYLOAD(this, "STATE_RESP_PAYLOAD", "8", "9", NO_COMMENT),
    _fifo0_(this, ""),
    REQ_FIFO_WIDTH(this, "REQ_FIFO_WIDTH", &CALCWIDTHx(3, &i_pcie_dmai.last,
                                                          &i_pcie_dmai.strob,
                                                          &i_pcie_dmai.data)),
    RESP_FIFO_WIDTH(this, "RESP_FIFO_WIDTH", &CALCWIDTHx(3, &o_pcie_dmao.last,
                                                            &o_pcie_dmao.strob,
                                                            &o_pcie_dmao.data)),
    // signals
    w_pcie_nrst(this, "w_pcie_nrst", "1"),
    wb_reqfifo_payload_i(this, "wb_reqfifo_payload_i", "REQ_FIFO_WIDTH"),
    wb_reqfifo_payload_o(this, "wb_reqfifo_payload_o", "REQ_FIFO_WIDTH"),
    w_reqfifo_full(this, "w_reqfifo_full", "1"),
    w_reqfifo_empty(this, "w_reqfifo_empty", "1"),
    w_reqfifo_rd(this, "w_reqfifo_rd", "1"),
    wb_respfifo_payload_i(this, "wb_respfifo_payload_i", "RESP_FIFO_WIDTH"),
    wb_respfifo_payload_o(this, "wb_respfifo_payload_o", "RESP_FIFO_WIDTH"),
    w_respfifo_full(this, "w_respfifo_full", "1"),
    w_respfifo_empty(this, "w_respfifo_empty", "1"),
    w_respfifo_wr(this, "w_respfifo_wr", "1"),
    // registers
    state(this, "state", "8", "STATE_RST", NO_COMMENT),
    dw0(this, "dw0", "32", RSTVAL_ZERO, NO_COMMENT),
    dw1(this, "dw1", "32", RSTVAL_ZERO, NO_COMMENT),
    dw2(this, "dw2", "32", RSTVAL_ZERO, NO_COMMENT),
    dw3(this, "dw3", "32", RSTVAL_ZERO, NO_COMMENT),
    xlen(this, "xlen", "8", "0", "AXI Burst Len - 1"),
    xsize(this, "xsize", "3", "0", "AXI Burst size: 0=1B, 1=2B, 2=4B, 3=8B,.."),
    xaddr(this, "xaddr", "CFG_SYSBUS_ADDR_BITS", "0", "AXI request address"),
    xwstrb(this, "xwstrb", "CFG_SYSBUS_DATA_BYTES", RSTVAL_ZERO, NO_COMMENT),
    xwdata(this, "xwdata", "CFG_SYSBUS_DATA_BITS", RSTVAL_ZERO, NO_COMMENT),
    xwena(this, "xwena", "1", RSTVAL_ZERO, "AXI light: RW and W at the same time without burst"),
    xrdata(this, "xrdata", "CFG_SYSBUS_DATA_BITS", RSTVAL_ZERO, NO_COMMENT),
    resp_data_ena(this, "resp_data_ena", "1", RSTVAL_ZERO, "TLP with payload"),
    resp_data(this, "resp_data", "64", RSTVAL_ZERO, NO_COMMENT),
    resp_last(this, "resp_last", "1", RSTVAL_ZERO, NO_COMMENT),
    byte_cnt(this, "byte_cnt", "12", RSTVAL_ZERO, "Byte counter to send in payload"),
    busy(this, &i_clk, CLK_POSEDGE, &i_nrst, ACTIVE_LOW, "busy", "1", RSTVAL_ZERO, NO_COMMENT),
    //
    comb(this),
    reqfifo(this, "reqfifo"),
    respfifo(this, "respfifo")
{
    Operation::start(this);

    TEXT("PCIE EP (200 MHz) -> DMA (40 MHz)");
    reqfifo.abits.setObjValue(SCV_get_cfg_type(this, "CFG_PCIE_DMAFIFO_DEPTH"));
    reqfifo.dbits.setObjValue(&REQ_FIFO_WIDTH);
    NEW(reqfifo, reqfifo.getName().c_str());
        CONNECT(reqfifo, 0, reqfifo.i_wclk, i_pcie_usr_clk);
        CONNECT(reqfifo, 0, reqfifo.i_wrstn, w_pcie_nrst);
        CONNECT(reqfifo, 0, reqfifo.i_wr, i_pcie_dmai.valid);
        CONNECT(reqfifo, 0, reqfifo.i_wdata, wb_reqfifo_payload_i);
        CONNECT(reqfifo, 0, reqfifo.o_wfull, w_reqfifo_full);
        CONNECT(reqfifo, 0, reqfifo.i_rclk, i_clk);
        CONNECT(reqfifo, 0, reqfifo.i_rrstn, i_nrst);
        CONNECT(reqfifo, 0, reqfifo.i_rd, w_reqfifo_rd);
        CONNECT(reqfifo, 0, reqfifo.o_rdata, wb_reqfifo_payload_o);
        CONNECT(reqfifo, 0, reqfifo.o_rempty, w_reqfifo_empty);
    ENDNEW();

    TEXT("DMA (40 MHz) -> PCIE EP (200 MHz)");
    respfifo.abits.setObjValue(SCV_get_cfg_type(this, "CFG_PCIE_DMAFIFO_DEPTH"));
    respfifo.dbits.setObjValue(&RESP_FIFO_WIDTH);
    NEW(respfifo, respfifo.getName().c_str());
        CONNECT(respfifo, 0, respfifo.i_wclk, i_clk);
        CONNECT(respfifo, 0, respfifo.i_wrstn, i_nrst);
        CONNECT(respfifo, 0, respfifo.i_wr, w_respfifo_wr);
        CONNECT(respfifo, 0, respfifo.i_wdata, wb_respfifo_payload_i);
        CONNECT(respfifo, 0, respfifo.o_wfull, w_respfifo_full);
        CONNECT(respfifo, 0, respfifo.i_rclk, i_pcie_usr_clk);
        CONNECT(respfifo, 0, respfifo.i_rrstn, w_pcie_nrst);
        CONNECT(respfifo, 0, respfifo.i_rd, i_pcie_dmai.ready);
        CONNECT(respfifo, 0, respfifo.o_rdata, wb_respfifo_payload_o);
        CONNECT(respfifo, 0, respfifo.o_rempty, w_respfifo_empty);
    ENDNEW();

    Operation::start(&comb);
    proc_comb();
}

void pcie_dma::proc_comb() {
    types_amba* cfg = glob_types_amba_;
    SETZERO(comb.v_req_ready);
    SETZERO(comb.vb_req_addr);
    SETZERO(comb.v_resp_valid);
    SETZERO(comb.vb_resp_data);
    SETZERO(comb.vb_resp_strob);
    SETZERO(comb.v_resp_last);
    SETVAL(comb.vb_xmsto, cfg->axi4_master_out_none);

TEXT();
    SETVAL(comb.vb_xmst_cfg.descrsize, glob_pnp_cfg_->PNP_CFG_DEV_DESCR_BYTES);
    SETVAL(comb.vb_xmst_cfg.descrtype, glob_pnp_cfg_->PNP_CFG_TYPE_MASTER);
    SETVAL(comb.vb_xmst_cfg.vid, glob_pnp_cfg_->VENDOR_OPTIMITECH);
    SETVAL(comb.vb_xmst_cfg.did, glob_pnp_cfg_->OPTIMITECH_PCIE_DMA);

TEXT();
    TEXT("Request FIFO inputs/outputs:");
    SETVAL(wb_reqfifo_payload_i, CCx(3, &i_pcie_dmai.last,
                                       &i_pcie_dmai.strob,
                                       &i_pcie_dmai.data));
TEXT();
    SPLx(wb_reqfifo_payload_i, 3, &comb.v_req_last,
                                 &comb.vb_req_strob,
                                 &comb.vb_req_data);

TEXT();
    TEXT("Response FIFO inputs/outputs:");
    SETVAL(wb_respfifo_payload_i, CCx(3, &comb.v_resp_last,
                                         &comb.vb_resp_strob,
                                         &comb.vb_resp_data));

TEXT();
TEXT("Temporary register");
    SWITCH(state);
    CASE(STATE_RST);
        SETONE(comb.v_req_ready);
        IF (NZ(w_reqfifo_empty));
            SETVAL(dw0, BITS(comb.vb_req_data, 31, 0));
            SETVAL(dw1, BITS(comb.vb_req_data, 63, 32));
            SETVAL(state, STATE_DW3DW4);
        ENDIF();
        ENDCASE();

TEXT();
    CASE(STATE_DW3DW4);
        TEXT("64-bits BAR could use 3DW header because if addr[63:32] is zero");
        TEXT("TLP behaviour is undefined (Xilinx example ignores it):");
        TEXT("  dw2 = addr[63:32]");
        TEXT("  dw3 = {addr[31:2], 00}");
        SETONE(comb.v_req_ready);
        SETVAL(xlen, DEC(BITS(dw0, 7, 0)), "warning: Actual size of Length is 10 bits");
        SETVAL(dw2, BITS(comb.vb_req_data, 31, 0));
        SETZERO(dw3);
        SETZERO(busy);
        IF (NZ(w_reqfifo_empty));
            SETONE(busy);
            TEXT("fmt[0] = 1 when 4DW header is used");
            IF (NZ(BIT(dw0, 29)));
                SETVAL(dw3, BITS(comb.vb_req_data, 63, 32));
            ENDIF();
            IF (EZ(BIT(dw0, 30)));
                TEXT("fmt[1]=0: read operation");
                SETVAL(state, STATE_AR);

                TEXT();
                IF (EZ(BIT(dw0, 29)));
                    TEXT("fmt[0]=0: 3DW header (32-bits address):");
                    SETVAL(xsize, CONST("2", 3));
                    SETVAL(byte_cnt, CC2(BITS(dw0, 7, 0), CONST("0", 2)));
                    SETBITS(comb.vb_req_addr, 31, 0, BITS(comb.vb_req_data, 31, 0));
                ELSE();
                    TEXT("fmt[0]=1: 4DW header (64-bits address):");
                    SETVAL(xsize, CONST("3", 3));
                    SETVAL(byte_cnt, CC2(BITS(dw0, 7, 0), CONST("0", 3)));
                    SETVAL(comb.vb_req_addr, CC2(BITS(comb.vb_req_data, 31, 0), BITS(comb.vb_req_data, 63, 32)));
                ENDIF();
                SETBITS(comb.vb_req_addr, 1, 0, CONST("0", 2));
            ELSE();
                TEXT("fmt[1] = 1: write operation");
                SETVAL(state, STATE_AW);
                SETVAL(xwstrb, BITS(dw1, 7, 0));

                TEXT();
                IF (EZ(BIT(dw0, 29)));
                    TEXT("fmt[0]=0: 3DW header (32-bits address):");
                    SETVAL(xsize, CONST("2", 3));
                    SETVAL(byte_cnt, CC2(BITS(dw0, 7, 0), CONST("0", 2)));
                    SETBITS(comb.vb_req_addr, 31, 0, BITS(comb.vb_req_data, 31, 0));
                    SETVAL(xwdata, BITS(comb.vb_req_data, 63, 32));
                    SETVAL(xwena, comb.v_req_last, "AXI Light: burst transactions are no supported");
                ELSE();
                    TEXT("fmt[0]=1: 4DW header (64-bits address):");
                    SETVAL(xsize, CONST("3", 3));
                    SETVAL(byte_cnt, CC2(BITS(dw0, 7, 0), CONST("0", 3)));
                    SETVAL(comb.vb_req_addr, CC2(BITS(comb.vb_req_data, 31, 0), BITS(comb.vb_req_data, 63, 32)));
                ENDIF();
            ENDIF();
        ENDIF();
        SETVAL(xaddr, BITS(comb.vb_req_addr, DEC(cfg->CFG_SYSBUS_ADDR_BITS), CONST("0")));
        ENDCASE();

    CASE(STATE_AR);
        SETONE(comb.vb_xmsto.ar_valid);
        SETVAL(comb.vb_xmsto.ar_bits.addr, BITS(xaddr, DEC(cfg->CFG_SYSBUS_ADDR_BITS), CONST("0")));
        SETVAL(comb.vb_xmsto.ar_bits.len, xlen);
        SETVAL(comb.vb_xmsto.ar_bits.size, xsize);
        SETONE(resp_data_ena);
        IF(NZ(i_xmsti.ar_ready));
            SETVAL(state, STATE_RESP_DW0DW1);
        ENDIF();
        ENDCASE();
    CASE(STATE_R);
        SETONE(comb.vb_xmsto.r_ready);
        IF(NZ(i_xmsti.r_valid));
            SETVAL(xrdata, i_xmsti.r_data);
            SETVAL(state, STATE_RESP_PAYLOAD);
        ENDIF();
        ENDCASE();
    CASE(STATE_AW);
        SETONE(comb.vb_xmsto.aw_valid);
        SETVAL(comb.vb_xmsto.ar_bits.addr, BITS(xaddr, DEC(cfg->CFG_SYSBUS_ADDR_BITS), CONST("0")));
        SETVAL(comb.vb_xmsto.ar_bits.len, xlen);
        SETVAL(comb.vb_xmsto.ar_bits.size, xsize);
        SETVAL(comb.vb_xmsto.w_valid, xwena);
        SETVAL(comb.vb_xmsto.w_strb, xwstrb);
        SETVAL(comb.vb_xmsto.w_data, CC2(BITS(xwdata, 31, 0), BITS(xwdata, 31, 0)));
        IF(NZ(i_xmsti.aw_ready));
            IF (AND2(NZ(xwena), NZ(i_xmsti.w_ready)));
                TEXT("AXI light: no burst transactions:");
                SETVAL(state, STATE_B);
                SETZERO(xwena);
            ELSE();
                SETVAL(state, STATE_W);
            ENDIF();
        ENDIF();
        ENDCASE();
    CASE(STATE_W);
        SETONE(comb.v_req_ready);
        SETVAL(comb.vb_xmsto.w_valid, NZ(w_reqfifo_empty));
        SETVAL(comb.vb_xmsto.w_strb, comb.vb_req_strob);
        SETVAL(comb.vb_xmsto.w_data, comb.vb_req_data);
        IF(AND2(NZ(w_reqfifo_empty), NZ(i_xmsti.w_ready)));
            IF (NZ(comb.v_req_last));
                SETVAL(state, STATE_B);
            ENDIF();
        ENDIF();
        ENDCASE();
    CASE(STATE_B);
        SETVAL(comb.vb_xmsto.b_ready, EZ(w_respfifo_full));
        IF(AND2(EZ(w_respfifo_full), NZ(i_xmsti.b_valid)));
            SETVAL(state, STATE_RESP_DW0DW1);
        ENDIF();
        ENDCASE();

TEXT();
    CASE(STATE_RESP_DW0DW1);
        SETONE(comb.v_resp_valid);
        SETVAL(comb.vb_resp_strob, CONST("0xFF", 8));
        SETBITS(comb.vb_resp_data, 9, 0, BITS(dw0, 9, 0), "DW0[9:0] Length");
        SETBITS(comb.vb_resp_data, 11, 10, CONST("0", 2), "DW0[11:10] Reserved");
        SETBITS(comb.vb_resp_data, 13, 12, BITS(dw0, 13, 12), "DW0[13:12] Attr");
        SETBIT(comb.vb_resp_data, 14, BIT(dw0, 14), "DW0[14] EP");
        SETBIT(comb.vb_resp_data, 15, BIT(dw0, 15), "DW0[15] TD");
        SETBITS(comb.vb_resp_data, 19, 16, CONST("0", 4), "DW0[19:16] Reserved");
        SETBITS(comb.vb_resp_data, 22, 20, BITS(dw0, 22, 20), "DW0[22:20] TC");
        SETBIT(comb.vb_resp_data, 23, CONST("0", 1), "DW0[23] Reserved");
        SETBITS(comb.vb_resp_data, 28, 24, CONST("0xA", 5), "DW0[28:224] Type: Completion data");
        SETBITS(comb.vb_resp_data, 30, 29, CC2(resp_data_ena, CONST("0", 1)), "DW0[30:29] Fmt");
        SETBIT(comb.vb_resp_data, 31, CONST("0", 1), "DW0[31] Reserved");
        SETBITS(comb.vb_resp_data, 43, 32, byte_cnt, "DW1[11:0] Byte Count");
        SETBIT(comb.vb_resp_data, 44, CONST("0", 1), "DW1[12] BCM");
        SETBITS(comb.vb_resp_data, 47, 45, CONST("0", 3), "DW1[15:13] Status");
        SETBITS(comb.vb_resp_data, 63, 48, i_pcie_completer_id, "DW1[31:16] Completer ID");
        IF (NZ(w_respfifo_full));
            SETVAL(state, STATE_RESP_DW2DW3);
        ENDIF();
        ENDCASE();

TEXT();
    CASE(STATE_RESP_DW0DW1);
        SETONE(comb.v_resp_valid);
        IF (NZ(w_respfifo_full));
            IF (NZ(resp_data_ena));
                SETVAL(comb.vb_resp_strob, CONST("0x0F", 8));
                SETVAL(state, STATE_R);
            ELSE();
                SETVAL(state, STATE_RST);
            ENDIF();
        ENDIF();
        ENDCASE();

TEXT();
    CASE(STATE_RESP_PAYLOAD);
        IF (NZ(w_respfifo_full));
            IF (EZ(resp_last));
                SETVAL(state, STATE_R);
            ELSE();
                SETVAL(state, STATE_RST);
            ENDIF();
        ENDIF();
        ENDCASE();

TEXT();
    CASEDEF();
        SETVAL(state, STATE_RST);
        ENDCASE();
    ENDSWITCH();

TEXT();
    SETVAL(w_pcie_nrst, AND2_L(i_nrst, INV(i_pcie_usr_rst)));
    SPLx(wb_respfifo_payload_o, 3, &o_pcie_dmao.last,
                                   &o_pcie_dmao.strob,
                                   &o_pcie_dmao.data);
    SETVAL(o_pcie_dmao.ready, INV(w_reqfifo_full));
    SETVAL(o_pcie_dmao.valid, INV(w_respfifo_empty));
    SETVAL(o_pcie_dmao.busy, busy);
    SETVAL(w_respfifo_wr, comb.v_resp_valid);
    SETVAL(w_reqfifo_rd, comb.v_req_ready);
    SETVAL(o_xmst_cfg, comb.vb_xmst_cfg);
    SETVAL(o_xmsto, cfg->axi4_master_out_none);
}
