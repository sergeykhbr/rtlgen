// 
//  Copyright 2025 Sergey Khabarov, sergeykhbr@gmail.com
// 
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
// 
//      http://www.apache.org/licenses/LICENSE-2.0
// 
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.
// 

#include "pcie_dma.h"

pcie_dma::pcie_dma(GenObject *parent, const char *name, const char *comment) :
    ModuleObject(parent, "pcie_dma", name, comment),
    i_nrst(this, "i_nrst", "1", "System Reset: active LOW"),
    i_clk(this, "i_clk", "1", "System bus clock"),
    i_pcie_phy_clk(this, "i_pcie_phy_clk", "1", "PCIE clock generated by end-point"),
    _text0_(this, "PCIE EP - DMA engine interface"),
    i_pcie_completer_id(this, "i_pcie_completer_id", "16", "Bus, Device, Function"),
    o_dma_state(this, "o_dma_state", "4", "State machine debug output, connected to APB controller"),
    i_pcie_dmai(this, "i_pcie_dmai", "PCIE-EP to system DMA requests"),
    o_pcie_dmao(this, "o_pcie_dmao", "System DMA responds to PCIE EP"),
    _text1_(this, "DMA engine interface - System on Chip interface"),
    o_xmst_cfg(this, "o_xmst_cfg", "PCIE DMA master interface descriptor"),
    i_xmsti(this, "i_xmsti"),
    o_xmsto(this, "o_xmsto"),
    // params
    _fmt0_(this, ""),
    _fmt1_(this, "fmt: indicates the size of the header"),
    TLP_FMT_3DW_NOPAYLOAD(this, "TLP_FMT_3DW_NOPAYLOAD", "2", "0", "3DW header without payload"),
    TLP_FMT_4DW_NOPAYLOAD(this, "TLP_FMT_4DW_NOPAYLOAD", "2", "1", "4DW header without payload"),
    TLP_FMT_3DW_PAYLOAD(this, "TLP_FMT_3DW_PAYLOAD", "2", "2", "3DW header with payload"),
    TLP_FMT_4DW_PAYLOAD(this, "TLP_FMT_4DW_PAYLOAD", "2", "3", "4DW header with payload"),
    _stat0_(this, ""),
    _stat1_(this, "TLP Completion Status"),
    TLP_STATUS_SUCCESS(this, "TLP_STATUS_SUCCESS", "3", "0", "Successful completion"),
    TLP_STATUS_UNSUPPORTED(this, "TLP_STATUS_UNSUPPORTED", "3", "1", "Unsupported Request (UR)"),
    TLP_STATUS_ABORTED(this, "TLP_STATUS_ABORTED", "3", "4", "Completer Abort (CA)"),
    _state0_(this, ""),
    _state1_(this, "State machine to parse TLP"),
    STATE_RST(this, "STATE_RST", "8", "0x0", NO_COMMENT),
    STATE_DW3DW4(this, "STATE_DW3DW4", "8", "1", NO_COMMENT),
    STATE_AR(this, "STATE_AR", "8", "2", NO_COMMENT),
    STATE_R_SINGLE32(this, "STATE_R_SINGLE32", "8", "3", NO_COMMENT),
    STATE_R(this, "STATE_R", "8", "4", NO_COMMENT),
    STATE_AW(this, "STATE_AW", "8", "5", NO_COMMENT),
    STATE_W(this, "STATE_W", "8", "6", NO_COMMENT),
    STATE_B(this, "STATE_B", "8", "7", NO_COMMENT),
    STATE_RESP_DW0DW1(this, "STATE_RESP_DW0DW1", "8", "8", NO_COMMENT),
    STATE_RESP_DW2DW3(this, "STATE_RESP_DW2DW3", "8", "9", NO_COMMENT),
    _fifo0_(this, ""),
    REQ_FIFO_WIDTH(this, "REQ_FIFO_WIDTH", &CALCWIDTHx(3, &i_pcie_dmai.last,
                                                          &i_pcie_dmai.strob,
                                                          &i_pcie_dmai.data)),
    RESP_FIFO_WIDTH(this, "RESP_FIFO_WIDTH", &CALCWIDTHx(3, &o_pcie_dmao.last,
                                                            &o_pcie_dmao.strob,
                                                            &o_pcie_dmao.data)),
    // signals
    wb_reqfifo_payload_i(this, "wb_reqfifo_payload_i", "REQ_FIFO_WIDTH"),
    wb_reqfifo_payload_o(this, "wb_reqfifo_payload_o", "REQ_FIFO_WIDTH"),
    w_reqfifo_full(this, "w_reqfifo_full", "1"),
    w_reqfifo_empty(this, "w_reqfifo_empty", "1"),
    w_reqfifo_rd(this, "w_reqfifo_rd", "1"),
    wb_respfifo_payload_i(this, "wb_respfifo_payload_i", "RESP_FIFO_WIDTH"),
    wb_respfifo_payload_o(this, "wb_respfifo_payload_o", "RESP_FIFO_WIDTH"),
    w_respfifo_full(this, "w_respfifo_full", "1"),
    w_respfifo_empty(this, "w_respfifo_empty", "1"),
    w_respfifo_wr(this, "w_respfifo_wr", "1"),
    // registers
    state(this, "state", "4", "STATE_RST", NO_COMMENT),
    dw0(this, "dw0", "32", RSTVAL_ZERO, NO_COMMENT),
    dw1(this, "dw1", "32", RSTVAL_ZERO, NO_COMMENT),
    dw2(this, "dw2", "32", RSTVAL_ZERO, NO_COMMENT),
    dw3(this, "dw3", "32", RSTVAL_ZERO, NO_COMMENT),
    req_rd_locked(this, "req_rd_locked", "1", RSTVAL_ZERO, "Read locked request"),
    xlen(this, "xlen", "8", "0", "AXI Burst Len - 1"),
    xsize(this, "xsize", "3", "0", "AXI Burst size: 0=1B, 1=2B, 2=4B, 3=8B,.."),
    xaddr(this, "xaddr", "CFG_SYSBUS_ADDR_BITS", "0", "AXI request address"),
    xwstrb(this, "xwstrb", "CFG_SYSBUS_DATA_BYTES", RSTVAL_ZERO, NO_COMMENT),
    xwdata(this, "xwdata", "CFG_SYSBUS_DATA_BITS", RSTVAL_ZERO, NO_COMMENT),
    xwena(this, "xwena", "1", RSTVAL_ZERO, "AXI light: RW and W at the same time without burst"),
    xrdata(this, "xrdata", "CFG_SYSBUS_DATA_BITS", RSTVAL_ZERO, NO_COMMENT),
    xerr(this, "xerr", "2", "AXI_RESP_OKAY", NO_COMMENT),
    resp_with_payload(this, "resp_with_payload", "1", RSTVAL_ZERO, "TLP with payload"),
    resp_data(this, "resp_data", "64", RSTVAL_ZERO, NO_COMMENT),
    resp_status(this, "resp_status", "3", "TLP_STATUS_SUCCESS", NO_COMMENT),
    resp_cpl(this, "resp_cpl", "7", RSTVAL_ZERO, "Completion packet"),
    byte_cnt(this, "byte_cnt", "12", RSTVAL_ZERO, "Byte counter to send in payload"),
    //
    comb(this),
    reqfifo(this, "reqfifo"),
    respfifo(this, "respfifo")
{
    Operation::start(this);

    TEXT("PCIE EP (200 MHz) -> DMA (40 MHz)");
    reqfifo.abits.setObjValue(SCV_get_cfg_type(this, "CFG_PCIE_DMAFIFO_DEPTH"));
    reqfifo.dbits.setObjValue(&REQ_FIFO_WIDTH);
    NEW(reqfifo, reqfifo.getName().c_str());
        CONNECT(reqfifo, 0, reqfifo.i_nrst, i_nrst);
        CONNECT(reqfifo, 0, reqfifo.i_wclk, i_pcie_phy_clk);
        CONNECT(reqfifo, 0, reqfifo.i_wr, i_pcie_dmai.valid);
        CONNECT(reqfifo, 0, reqfifo.i_wdata, wb_reqfifo_payload_i);
        CONNECT(reqfifo, 0, reqfifo.o_wfull, w_reqfifo_full);
        CONNECT(reqfifo, 0, reqfifo.i_rclk, i_clk);
        CONNECT(reqfifo, 0, reqfifo.i_rd, w_reqfifo_rd);
        CONNECT(reqfifo, 0, reqfifo.o_rdata, wb_reqfifo_payload_o);
        CONNECT(reqfifo, 0, reqfifo.o_rempty, w_reqfifo_empty);
    ENDNEW();

    TEXT("DMA (40 MHz) -> PCIE EP (200 MHz)");
    respfifo.abits.setObjValue(SCV_get_cfg_type(this, "CFG_PCIE_DMAFIFO_DEPTH"));
    respfifo.dbits.setObjValue(&RESP_FIFO_WIDTH);
    NEW(respfifo, respfifo.getName().c_str());
        CONNECT(respfifo, 0, respfifo.i_nrst, i_nrst);
        CONNECT(respfifo, 0, respfifo.i_wclk, i_clk);
        CONNECT(respfifo, 0, respfifo.i_wr, w_respfifo_wr);
        CONNECT(respfifo, 0, respfifo.i_wdata, wb_respfifo_payload_i);
        CONNECT(respfifo, 0, respfifo.o_wfull, w_respfifo_full);
        CONNECT(respfifo, 0, respfifo.i_rclk, i_pcie_phy_clk);
        CONNECT(respfifo, 0, respfifo.i_rd, i_pcie_dmai.ready);
        CONNECT(respfifo, 0, respfifo.o_rdata, wb_respfifo_payload_o);
        CONNECT(respfifo, 0, respfifo.o_rempty, w_respfifo_empty);
    ENDNEW();

    Operation::start(&comb);
    proc_comb();
}

void pcie_dma::proc_comb() {
    types_amba* amba = glob_types_amba_;
    SETZERO(comb.v_req_ready);
    SETZERO(comb.vb_req_addr);
    SETZERO(comb.v_resp_valid);
    SETZERO(comb.vb_resp_data);
    SETZERO(comb.vb_resp_strob);
    SETZERO(comb.v_resp_last);
    SETZERO(comb.v_single_tlp);
    SETVAL(comb.vb_xmsto, amba->axi4_master_out_none);

TEXT();
    IF (EQ(BITS(dw0, 9, 0), CONST("1", 10)));
        TEXT("DW0[9:0] = Length number of DW (4-bytes) for 32/64 bars");
        SETONE(comb.v_single_tlp);
    ENDIF();
    SETVAL(comb.vb_xmst_cfg.descrsize, glob_pnp_cfg_->PNP_CFG_DEV_DESCR_BYTES);
    SETVAL(comb.vb_xmst_cfg.descrtype, glob_pnp_cfg_->PNP_CFG_TYPE_MASTER);
    SETVAL(comb.vb_xmst_cfg.vid, glob_pnp_cfg_->VENDOR_OPTIMITECH);
    SETVAL(comb.vb_xmst_cfg.did, glob_pnp_cfg_->OPTIMITECH_PCIE_DMA);
    CALLF(&comb.vb_xbytes, amba->XSizeToBytes, 1, &xsize);

TEXT();
    TEXT("Request address bits [1:0] are not transmitted, should be restored from BE[3:0]:");
    TEXT("be[3:0] => addr[1:0]");
    TEXT("0000    => 00");
    TEXT("xxx1    => 00");
    TEXT("xx10    => 01");
    TEXT("x100    => 10");
    TEXT("1000    => 11");
    IF (NZ(BIT(dw1, 0)));
        SETVAL(comb.vb_req_addr1_0, CONST("0", 2));
    ELSIF(NZ(BIT(dw1, 1)));
        SETVAL(comb.vb_req_addr1_0, CONST("1", 2));
    ELSIF(NZ(BIT(dw1, 2)));
        SETVAL(comb.vb_req_addr1_0, CONST("2", 2));
    ELSIF(NZ(BIT(dw1, 3)));
        SETVAL(comb.vb_req_addr1_0, CONST("3", 2));
    ELSE();
        SETVAL(comb.vb_req_addr1_0, CONST("0", 2));
    ENDIF();

TEXT();
    TEXT("Request FIFO inputs/outputs:");
    SETVAL(wb_reqfifo_payload_i, CCx(3, &i_pcie_dmai.last,
                                       &i_pcie_dmai.strob,
                                       &i_pcie_dmai.data));
TEXT();
    SPLx(wb_reqfifo_payload_o, 3, &comb.v_req_last,
                                 &comb.vb_req_strob,
                                 &comb.vb_req_data);

TEXT();
TEXT("Temporary register");
    SWITCH(state);
    CASE(STATE_RST);
        SETONE(comb.v_req_ready);
        SETVAL(resp_status, TLP_STATUS_SUCCESS);
        SETZERO(req_rd_locked);
        SETZERO(resp_cpl);
        SETZERO(resp_with_payload);
        IF (EZ(w_reqfifo_empty));
            SETVAL(dw0, BITS(comb.vb_req_data, 31, 0));
            SETVAL(dw1, BITS(comb.vb_req_data, 63, 32));
            SETVAL(state, STATE_DW3DW4);
        ENDIF();
        ENDCASE();

TEXT();
    CASE(STATE_DW3DW4);
        TEXT("64-bits BAR could use 3DW header because if addr[63:32] is zero");
        TEXT("TLP behaviour is undefined (Xilinx example ignores it):");
        TEXT("  dw2 = addr[63:32]");
        TEXT("  dw3 = {addr[31:2], 00}");
        SETONE(comb.v_req_ready);
        SETVAL(xlen, DEC(BITS(dw0, 7, 0)), "warning: Actual size of Length is 10 bits. 0 is 1024 DWs (4096 Bytes)");
        SETVAL(dw2, BITS(comb.vb_req_data, 31, 0));
        SETZERO(dw3);
        IF (EZ(w_reqfifo_empty));
            TEXT("fmt[0] = 1 when 4DW header is used");
            IF (NZ(BIT(dw0, 29)));
                SETVAL(dw3, BITS(comb.vb_req_data, 63, 32));
            ENDIF();
            IF (EZ(BIT(dw0, 30)));
                TEXT("fmt[1]=0: read operation");
                SETVAL(state, STATE_AR);
                SWITCH (BITS(dw0, 28, 24), "DW0[28:24] = Type[4:0]");
                CASE (CONST("0x1", 5));
                    TEXT("Read Locked request (in case of error becomes PCIE_CPL_LOCKED_READ_NODATA:");
                    SETVAL(resp_cpl, pcie_cfg_->PCIE_CPL_LOCKED_READ);
                    SETONE(req_rd_locked);
                    ENDCASE();
                CASE (CONST("0x2", 5));
                    TEXT("I/O Read request:");
                    SETVAL(resp_cpl, pcie_cfg_->PCIE_CPL_DATA);
                    ENDCASE();
                CASE(CONST("0x5", 5));
                    TEXT("Configuration Read request Root Port (type 1):");
                    SETVAL(resp_cpl, pcie_cfg_->PCIE_CPL_DATA);
                    ENDCASE();
                CASEDEF();
                    TEXT("Read request.");
                    SETVAL(resp_cpl, pcie_cfg_->PCIE_CPL_DATA);
                    ENDCASE();
                ENDSWITCH();

                TEXT();
                SETVAL(byte_cnt, CC2(BITS(dw0, 7, 0), CONST("0", 2)));
                IF (EZ(BIT(dw0, 29)));
                    TEXT("fmt[0]=0: 3DW header (32-bits address):");
                    SETVAL(xsize, CONST("2", 3));
                    SETBITS(comb.vb_req_addr, 31, 0, CC2(BITS(comb.vb_req_data, 31, 2), comb.vb_req_addr1_0));
                ELSE();
                    TEXT("fmt[0]=1: 4DW header (64-bits address):");
                    SETVAL(xsize, CONST("3", 3));
                    SETVAL(comb.vb_req_addr, CC3(BITS(comb.vb_req_data, 31, 0),
                                                 BITS(comb.vb_req_data, 63, 34),
                                                 comb.vb_req_addr1_0));
                ENDIF();
            ELSE();
                TEXT("fmt[1] = 1: write operation");
                SETVAL(state, STATE_AW);
                SETVAL(xwstrb, BITS(dw1, 7, 0));
                SWITCH (BITS(dw0, 28, 24), "DW0[28:24] = Type[4:0]");
                CASE (CONST("0x2", 5));
                    TEXT("I/O Write request:");
                    SETVAL(resp_cpl, pcie_cfg_->PCIE_CPL_NODATA);
                    ENDCASE();
                CASE(CONST("0x5", 5));
                    TEXT("Configuration Write request Root Port (type 1):");
                    SETVAL(resp_cpl, pcie_cfg_->PCIE_CPL_NODATA);
                    ENDCASE();
                CASEDEF();
                    TEXT("Write request. No completion.");
                    ENDCASE();
                ENDSWITCH();

                TEXT();
                SETVAL(byte_cnt, CC2(BITS(dw0, 7, 0), CONST("0", 2)));
                IF (EZ(BIT(dw0, 29)));
                    TEXT("fmt[0]=0: 3DW header (32-bits address):");
                    SETVAL(xsize, CONST("2", 3));
                    SETBITS(comb.vb_req_addr, 31, 0, CC2(BITS(comb.vb_req_data, 31, 2), comb.vb_req_addr1_0));
                    SETVAL(xwdata, CC2(BITS(comb.vb_req_data, 63, 32), BITS(comb.vb_req_data, 63, 32)));
                    SETVAL(xwena, comb.v_req_last, "AXI Light: burst transactions are no supported");
                ELSE();
                    TEXT("fmt[0]=1: 4DW header (64-bits address):");
                    SETVAL(xsize, CONST("3", 3));
                    SETVAL(comb.vb_req_addr, CC3(BITS(comb.vb_req_data, 31, 0),
                                                 BITS(comb.vb_req_data, 63, 34),
                                                 comb.vb_req_addr1_0));
                ENDIF();
            ENDIF();
        ENDIF();
        SETVAL(xaddr, BITS(comb.vb_req_addr, DEC(amba->CFG_SYSBUS_ADDR_BITS), CONST("0")));
        ENDCASE();

    CASE(STATE_AR);
        SETONE(comb.vb_xmsto.ar_valid);
        SETVAL(comb.vb_xmsto.ar_bits.addr, BITS(xaddr, DEC(amba->CFG_SYSBUS_ADDR_BITS), CONST("0")));
#if 1
        TEXT("sram base address: 64'h0000000008000000");
        SETVAL(comb.vb_xmsto.ar_bits.addr, CC2(CONST("0x00008001", 36), BITS(comb.vb_xmsto.ar_bits.addr, 11, 0)));
#endif
        SETVAL(comb.vb_xmsto.ar_bits.len, xlen);
        SETVAL(comb.vb_xmsto.ar_bits.size, xsize);
        SETVAL(comb.vb_xmsto.ar_bits.lock, req_rd_locked);
        SETONE(resp_with_payload);
        IF(NZ(i_xmsti.ar_ready));
            IF (NZ(comb.v_single_tlp));
                TEXT("3DW header + DW 32-bits payload");
                SETVAL(state, STATE_R_SINGLE32);
            ELSE();
                TEXT("3DW header only");
                SETVAL(state, STATE_RESP_DW0DW1);
            ENDIF();
        ENDIF();
        ENDCASE();
    CASE(STATE_R_SINGLE32);
        TEXT("32-bit single transactions (no bulk). MEM32 and IO only:");
        SETONE(comb.vb_xmsto.r_ready);
        SETVAL(xerr, i_xmsti.r_resp);
        IF (EZ(BIT(xaddr, 2)));
            SETVAL(xrdata, CC2(BITS(i_xmsti.r_data, 31, 0), BITS(i_xmsti.r_data, 31, 0)));
        ELSE();
            SETVAL(xrdata, CC2(BITS(i_xmsti.r_data, 63, 32), BITS(i_xmsti.r_data, 63, 32)));
        ENDIF();
        IF(NZ(i_xmsti.r_valid));
            SETVAL(state, STATE_RESP_DW0DW1);
        ENDIF();
        ENDCASE();
    CASE(STATE_R);
        SETVAL(comb.vb_xmsto.r_ready, INV_L(w_reqfifo_full));
        SETVAL(comb.v_resp_valid, i_xmsti.r_valid);
        SETVAL(comb.vb_resp_strob, CONST("0xFF", 8));
        SETVAL(comb.v_resp_last, INV_L(OR_REDUCE(xlen)));
        SETVAL(xerr, i_xmsti.r_resp);
        IF (EQ(xsize, CONST("2", 3)));
            TEXT("32-bit transactions:");
            IF (EZ(BIT(xaddr, 2)));
                SETVAL(comb.vb_resp_data, CC2(BITS(i_xmsti.r_data, 31, 0), BITS(i_xmsti.r_data, 31, 0)));
            ELSE();
                SETVAL(comb.vb_resp_data, CC2(BITS(i_xmsti.r_data, 63, 32), BITS(i_xmsti.r_data, 63, 32)));
            ENDIF();
        ELSE();
            TEXT("64-bit transactions:");
            SETVAL(comb.vb_resp_data, i_xmsti.r_data);
        ENDIF();

        TEXT();
        IF(AND2(NZ(i_xmsti.r_valid), EZ(w_respfifo_full)));
            TEXT("Burst support: ");
            IF (NE(i_xmsti.r_resp, amba->AXI_RESP_OKAY));
                SETVAL(resp_status, TLP_STATUS_ABORTED);
                IF (NZ(req_rd_locked));
                    TEXT("Error on Locked Read transaction:");
                    SETVAL(resp_cpl, pcie_cfg_->PCIE_CPL_LOCKED_READ_NODATA);
                ENDIF();
                SETVAL(state, STATE_RESP_DW0DW1);
            ELSIF (NZ(xlen));
                SETVAL(xlen, DEC(xlen));
                SETVAL(xaddr, ADD2(xaddr, comb.vb_xbytes));
                SETVAL(byte_cnt, SUB2(byte_cnt, comb.vb_xbytes));
            ELSE();
                SETVAL(state, STATE_RST);
            ENDIF();
        ENDIF();
        ENDCASE();
    CASE(STATE_AW);
        SETONE(comb.vb_xmsto.aw_valid);
        SETVAL(comb.vb_xmsto.aw_bits.addr, BITS(xaddr, DEC(amba->CFG_SYSBUS_ADDR_BITS), CONST("0")));
#if 1
        TEXT("sram base address: 64'h0000000008000000");
        SETVAL(comb.vb_xmsto.aw_bits.addr, CC2(CONST("0x00008001", 36), BITS(comb.vb_xmsto.aw_bits.addr, 11, 0)));
#endif
        SETVAL(comb.vb_xmsto.aw_bits.len, xlen);
        SETVAL(comb.vb_xmsto.aw_bits.size, xsize);
        SETVAL(comb.vb_xmsto.w_valid, xwena);
        SETVAL(comb.vb_xmsto.w_last, xwena);
        SETVAL(comb.vb_xmsto.w_strb, xwstrb);
        SETVAL(comb.vb_xmsto.w_data, CC2(BITS(xwdata, 31, 0), BITS(xwdata, 31, 0)));
        IF(NZ(i_xmsti.aw_ready));
            IF (AND2(NZ(xwena), NZ(i_xmsti.w_ready)));
                TEXT("AXI light: no burst transactions:");
                SETVAL(state, STATE_B);
                SETZERO(xwena);
            ELSE();
                SETVAL(state, STATE_W);
            ENDIF();
        ENDIF();
        ENDCASE();
    CASE(STATE_W);
        IF (NZ(xwena));
            SETZERO(xwena);
            SETONE(comb.vb_xmsto.w_valid);
            SETVAL(comb.vb_xmsto.w_strb, xwstrb);
            SETVAL(comb.vb_xmsto.w_data, xwdata);
            SETONE(comb.vb_xmsto.w_last);
            IF(NZ(i_xmsti.w_ready));
                SETVAL(state, STATE_B);
            ENDIF();
        ELSE();
            SETVAL(comb.v_req_ready, i_xmsti.w_ready);
            SETVAL(comb.vb_xmsto.w_valid, INV_L(w_reqfifo_empty));
            SETVAL(comb.vb_xmsto.w_strb, comb.vb_req_strob);
            SETVAL(comb.vb_xmsto.w_data, comb.vb_req_data);
            SETVAL(comb.vb_xmsto.w_last, INV_L(OR_REDUCE(xlen)));
            IF(AND2(EZ(w_reqfifo_empty), NZ(i_xmsti.w_ready)));
                IF (NZ(comb.v_req_last));
                    SETVAL(state, STATE_B);
                ENDIF();
            ENDIF();
        ENDIF();
        ENDCASE();
    CASE(STATE_B);
        SETONE(comb.vb_xmsto.b_ready);
        IF(NZ(i_xmsti.b_valid));
            SETVAL(xerr, i_xmsti.b_resp);
            IF (NE(i_xmsti.b_resp, amba->AXI_RESP_OKAY));
                SETVAL(resp_status, TLP_STATUS_ABORTED);
            ENDIF();
            IF(EZ(resp_cpl));
                TEXT("Posted write TLP without response");
                SETVAL(state, STATE_RST);
            ELSE();
                TEXT("Non-posted write TLP with response");
                SETVAL(state, STATE_RESP_DW0DW1);
            ENDIF();
        ENDIF();
        ENDCASE();

TEXT();
    CASE(STATE_RESP_DW0DW1);
        SETONE(comb.v_resp_valid);
        SETVAL(comb.vb_resp_strob, CONST("0xFF", 8));
        SETBITS(comb.vb_resp_data, 9, 0, BITS(dw0, 9, 0), "DW0[9:0] Length");
        SETBITS(comb.vb_resp_data, 11, 10, CONST("0", 2), "DW0[11:10] Reserved");
        SETBITS(comb.vb_resp_data, 13, 12, BITS(dw0, 13, 12), "DW0[13:12] Attr");
        SETBIT(comb.vb_resp_data, 14, BIT(dw0, 14), "DW0[14] EP");
        SETBIT(comb.vb_resp_data, 15, BIT(dw0, 15), "DW0[15] TD");
        SETBITS(comb.vb_resp_data, 19, 16, CONST("0", 4), "DW0[19:16] Reserved");
        SETBITS(comb.vb_resp_data, 22, 20, BITS(dw0, 22, 20), "DW0[22:20] TC");
        SETBIT(comb.vb_resp_data, 23, CONST("0", 1), "DW0[23] Reserved");
        SETBITS(comb.vb_resp_data, 30, 24, resp_cpl, "DW0[30:24] {Fmt,Type} Completion");
        SETBIT(comb.vb_resp_data, 31, CONST("0", 1), "DW0[31] Reserved");
        SETBITS(comb.vb_resp_data, 43, 32, byte_cnt, "DW1[11:0] Byte Count");
        SETBIT(comb.vb_resp_data, 44, CONST("0", 1), "DW1[12] BCM");
        SETBITS(comb.vb_resp_data, 47, 45, resp_status, "DW1[15:13] Status");
        SETBITS(comb.vb_resp_data, 63, 48, i_pcie_completer_id, "DW1[31:16] Completer ID");
        IF (EZ(w_respfifo_full));
            SETVAL(state, STATE_RESP_DW2DW3);
        ENDIF();
        ENDCASE();

TEXT();
    CASE(STATE_RESP_DW2DW3);
        SETONE(comb.v_resp_valid);
        SETVAL(comb.vb_resp_strob, CONST("0x0F", 8));
        SETBITS(comb.vb_resp_data, 6, 0, BITS(xaddr, 6, 0), "DW2[6:0] Low Address");
        SETBIT(comb.vb_resp_data, 7, CONST("0", 1), "DW2[7] Reserved");
        SETBITS(comb.vb_resp_data, 15, 8, BITS(dw1, 15, 8), "DW2[15:8] Tag");
        SETBITS(comb.vb_resp_data, 31, 16, BITS(dw1, 31, 16), "DW2[31:16] Requester ID");
        SETBITS(comb.vb_resp_data, 63, 32, BITS(xrdata, 31, 0), "DW3[31:0] payload (ignored by strob 0F)");
        IF (EZ(w_respfifo_full));
            IF(NE(resp_status, TLP_STATUS_SUCCESS));
                SETONE(comb.v_resp_last);
                SETVAL(state, STATE_RST);
            ELSIF (AND2(NZ(comb.v_single_tlp), NZ(resp_with_payload)));
                TEXT("DW4 response with the single DW payload");
                SETVAL(comb.vb_resp_strob, CONST("0xFF", 8));
                SETONE(comb.v_resp_last);
                SETVAL(state, STATE_RST);
            ELSIF (NZ(resp_with_payload));
                TEXT("DW3 response only if: payload not a single tlp32");
                SETVAL(state, STATE_R);
            ELSE();
                TEXT("DW3 without payload");
                SETONE(comb.v_resp_last);
                SETVAL(state, STATE_RST);
            ENDIF();
        ENDIF();
        ENDCASE();

TEXT();
    CASEDEF();
        SETVAL(state, STATE_RST);
        ENDCASE();
    ENDSWITCH();

TEXT();
    SYNC_RESET(*this);

TEXT();
    TEXT("Response FIFO inputs/outputs:");
    SETVAL(wb_respfifo_payload_i, CCx(3, &comb.v_resp_last,
                                         &comb.vb_resp_strob,
                                         &comb.vb_resp_data));
    SPLx(wb_respfifo_payload_o, 3, &o_pcie_dmao.last,
                                   &o_pcie_dmao.strob,
                                   &o_pcie_dmao.data);
    SETVAL(o_pcie_dmao.ready, INV(w_reqfifo_full));
    SETVAL(o_pcie_dmao.valid, INV(w_respfifo_empty));
    SETVAL(w_respfifo_wr, comb.v_resp_valid);
    SETVAL(w_reqfifo_rd, comb.v_req_ready);
    SETVAL(o_xmst_cfg, comb.vb_xmst_cfg);
    SETVAL(o_xmsto, comb.vb_xmsto);
}
